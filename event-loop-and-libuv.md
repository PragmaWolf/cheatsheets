# Библиотека libuv

[К оглавлению](README.md)

Библиотека отвечающая за неблокирующие операции и взаимодействие с операционной системой в Node.js.

Для эмуляции неблокирующего ввода/вывода использует внутри потоки (именно в ОС Linux, в других ОС такого нет).

> [!IMPORTANT]
> **В Linux**, на текущий момент, все операции с локальными файлами — блокирующие

**Особенности**
- По-умолчанию поднимаются 4 потока (именно в ОС Linux, в других ОС такого нет).

# Цикл событий (Event Loop)

Механизм Event Loop'a находится в libuv.

В Node.js цикл событий позволяет выполнять неблокирующие операции ввода/вывода путем выгрузки операций в ядро системы, когда это возможно.

Когда одна из этих операций завершается, ядро сообщает Node.js, что соответствующая этой операции функция обратного вызова (коллбэк) может быть добавлена в очередь опроса.

**Упрощённый порядок выполнения операций (фазы):**
- Таймеры (_кроме_ `setImmediate`).
- I/O коллбэки выполненных операций.
- Ожидание и подготовка (внутренние процессы цикла событий, может быть выполнен только `process.nextTick()`).
- Опрос (I/O операции, входящие: соединения, данные и т.д. Ставятся ядром в очередь).
  - Сначала выполнение скриптов для таймеров, порог которых истек.
  - Затем обработка событий из очереди опроса.
  - Может простаивать в ожидании задач или таймеров
  - Если в процессе ожидания истек порог таймера - он выполнится.
- Проверка (здесь запускается `setImmediate`).
- Коллбеки `close`.
- Проверка ожидается ли завершение каких-либо асинхронных операций ввода/вывода или таймеров, и завершает работу, если их нет.

**Особенности:**
Каждая фаза имеет очередь колбеков работающую по принципу FIFO. 
Каждая фаза выполняет сначала операции относящиеся к ней, а затем колбеки из очереди.
Фаза завершается, когда очередь колбеков исчерпана или если обработано максимально допустимое количество колбеков.

## Стек

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack). 

Стек определяет порядок выполнения кода и хранит локальные переменные.

Для переменных ссылочного типа на стеке хранится только указатель на данные в куче.

Если в рамках выполнения текущей функции (first) вызывается другая функция (second):
- Контекст текущей функции (first) помещается в стек вызовов.
- Новый контекст вызываемой функции (sercond) помещается в стек вызовов выше текущей.
- Когда выполнится вызываемая функция (second) ее контекст удаляется из стека вызовов.
- Выполнение передается контексту текущей функции (first).
- Когда выполняется текущая функция (first) ее контекст так же удаляется из стека вызовов.

## Куча

Область памяти, в которой хранятся ссылочные типы данных.

Может содержать таймеры и хранить значения переменных.

Функция-запуска таймеров вытягивает из кучи обработчик таймера с наименьшим временем и сравнивает это значение с временем выполнения событийного цикла. 
В случае, если время таймера меньше, то этот таймер останавливается (удаляется из кучи, его обработчик тоже удаляется из кучи). 
Далее идет проверка, нужно ли его перезапустить.

## Очередь

Это список задач для обработки. При выполнении задачи она удаляется из очереди, и код обработки помещается на стек.

**Особенности**
- Задача по сути является функцией с параметрами.
- Выполнение задачи вызывает ассоциированную с ней функцию, контекст которой в свою очередь помещается в стек вызовов.
- Задача считается выполненной, когда связанный с ней стек вызовов пуст.
- Каждая задача выполняется полностью, прежде чем начнёт обрабатываться следующая.

**Выборка задач из очереди**
- Выполнение микрозадач. Цикл событий обработает все микрозадачи до того, как перейдёт к следующей макрозадаче в очереди.
- Переход к следующей макрозадаче. После того как все микрозадачи выполнены, цикл событий возвращается к выбору и запуску следующей макрозадачи из очереди.
- Если в процессе выполнения макрозадачи возникают микрозадачи, они получают приоритет. Только после обработки всех микрозадач будет взята в работу одна следующая макрозадача.

## Микро и макро таски (задачи)

**Приоритет выполнения:** сначала будут обработаны задачи в стэке, далее микрозадачи и только после них будет выполнена макрозадача.

**Микрозадачи (или микротаски)** — это отложенные задачи, которые имеют приоритет над макрозадачами.
- операции с промисами (например, `Promise.then()`, `Promise.catch()`, `fetch()` и так далее);
- операции с очередью мутации (например, используемые в API `MutationObserver` для наблюдения за изменениями DOM);
- операции, связанные с `queueMicrotask()`, — функцией для явного добавления микрозадач.

**Макрозадачи (или макротаски)** — это тоже отложенные задачи, у которых меньший приоритет по сравнению с микрозадачами.
- обработка таймеров (`setTimeout`, `setInterval`);
- обработка событий пользовательского ввода (например, клики, скроллинг);
- выполнение AJAX-запросов.

Пример кода для понимания:
```javascript
console.log('Начало скрипта')

setTimeout(() => {
    console.log('Макрозадача: setTimeout')

    // Микрозадача, созданная внутри макрозадачи
    Promise.resolve().then(() => {
        console.log('Микрозадача: обработка промиса внутри setTimeout')
    })

    Promise.resolve().then(() => {
        console.log('Микрозадача: обработка промиса внутри setTimeout 2')
    })
}, 0)

setTimeout(() => {
    console.log('Макрозадача: setTimeout 2')
}, 0)

Promise.resolve().then(() => {
    console.log('Микрозадача: обработка первого промиса')
})

console.log('Конец скрипта')

// Будет выведено:
// Начало скрипта
// Конец скрипта
// Микрозадача: обработка первого промиса
// Макрозадача: setTimeout
// Микрозадача: обработка промиса внутри setTimeout
// Микрозадача: обработка промиса внутри setTimeout 2
// Макрозадача: setTimeout 2
```

**Таблица для упрощения понимания**

Заполнять табличку так, чтобы каждый скрипт, был на отдельной строке! Это важно.

| **Основной поток** | **Микротаски** | **Макротаски** |
|--------------------|----------------|----------------|

## process.nextTick()

Сразу помещается в текущий цикл (фазу). 

Будет обрабатываться после завершения текущей операции, независимо от текущей фазы цикла событий.

Когда вызывается `process.nextTick()` на любой фазе, все коллбэки, переданные процессу `process.nextTick()`, будут разрешаться до того, как цикл событий продолжится.

Удобно обращаться к коллбекам в функциях - гарантирует выполнение функции и вызов колбека. 
В частности, если синхронная функция вызывается с асинхронной сигнатурой (await).

**Варианты использования**
- Обрабатывать ошибки, очищать любые ненужные ресурсы или, возможно, повторять попытку до продолжения цикла обработки событий.
- Иногда необходимо разрешить выполнение коллбэка после разбора стека вызовов, но до продолжения цикла событий.

## setImmediate()

Срабатывает на следующей итерации или «тике» цикла событий.

Обработается только в фазе Проверки - выполнится после всех событий ввода/вывода.

[К оглавлению](README.md)

## Пример кода с описанием цикла событий и работы с макро и микро тасками

**Исходный код**
```javascript
const checkOrder = function () {
    console.log('1');

    const asyncFn = async function asyncFn() {
        console.log('2');
        await Promise.resolve(null);
        console.log('4');
    };
    asyncFn();

    new Promise((resolve) => {
        setTimeout(() => {
            resolve();
            ;
        }, 0);
    }).then(() => {
        console.log('6');
    });

    console.log('3');
};
checkOrder();
```

**Описание микро и макро тасок**

| **Основной поток** | **Микротаски**      | **Макротаски**   |
|--------------------|---------------------|------------------|
| console.log('1')   |                     |                  |
| Функция `asyncFn`  |                     |                  |
| console.log('2')   |                     |                  |
| создание Promise 1 |                     |                  |
| создание Promise 2 |                     |                  |
|                    |                     | setTimeout, 0    |
| console.log('3')   |                     |                  |
|                    | обработка Promise 1 |                  |
| console.log('4')   |                     |                  |
|                    |                     | console.log('5') |
|                    | обработка Promise 2 |                  |
| console.log('6')   |                     |                  |


**Первый цикл Event Loop**
```javascript
const checkOrder = function () {
    // Функция checkOrder является макротаской
    // Контекст функции checkOrder попадает в обработку первым и пишется в стек.
    // Этот console.log всегда выведется первым.
    console.log('1');

    // Объявляется вложенная функция asyncFn и сразу же запускается ниже.
    // Функция asyncFn является макротаской
    // Ее контекст будет вызван вторым и помещен в стек НАД функцией checkOrder.
    // Контекст функции asyncFn будет принят в работу сразу.
    const asyncFn = async function asyncFn() {
        // Этот console.log всегда выведется вторым, так как контекст функции asyncFn начал выполняться
        console.log('2');
        // Promise является микротаской
        // Откладывается выполнение контекста функции asyncFn до обработки Promise в следующем цикле
        await Promise.resolve(null);
        // ...
    };
    asyncFn();

    // Promise является микротаской
    // Создается операция Promise, контекст остается в функции checkOrder и ждет выполнения контекста функции asyncFn
    new Promise((resolve) => {
        // Весь функционал внутри коллбека Promise будет запущен когда до него дойдет исполнение контекста функции checkOrder
        // ...
    });

    // Все предыдущие операции отложены на следующий цикл, так как там Promise
    // Этот console.log всегда выведется третьим
    console.log('3');
};
```

**Второй цикл Event Loop**
```javascript
const checkOrder = function () {
    // Продолжает выполняться контекст функции asyncFn, так как Promise уже вернул результат null.
    const asyncFn = async function asyncFn() {
        // Микротаска Promise выполнена, контекст выполнения передан функции asyncFn
        // Этот console.log выведется четвертым
        console.log('4');
    };
    asyncFn();

    // Создается операция Promise, контекст остается в функции checkOrder и ждет выполнения контекста функции asyncFn
    new Promise((resolve) => {
        // Создается макротаска setTimeout
        setTimeout(() => {
            // ...
        }, 0);
    });
};
```

**Третий цикл Event Loop**
```javascript
const checkOrder = function () {
    new Promise((resolve) => {
        // Запускается контекст коллбека для setTimeout
        setTimeout(() => {
            // Выполняется код отдающий результат для Promise
            resolve();
            // Этот console.log всегда выведется пятым
            console.log('5');
        }, 0);
    }).then(() => {
        // Выполняется микротаска Promise
        // Этот console.log всегда выведется шестым
        console.log('6');
    });
};
```
