**[Языки программирования](../../README.md#languages) ::** 
**[JavaScript](../../README.md#languages-javascript) ::**
# Цикл событий (Event loop) и libuv

<!--
https://dev.to/lunaticmonk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-javascript-code-1j9
https://tproger.ru/articles/event-loop-dlya-chajnikov--prostymi-slovami-o-slozhnom-mehanizme-brauzera
https://dzen.ru/a/ZBLjyiRFhieJvAYP
https://habr.com/ru/articles/681882/
https://tproger.ru/blogs/effective-code-in-js-with-event-loop
https://habr.com/ru/articles/336498/
https://habr.com/ru/companies/oleg-bunin/articles/417461/
https://stackoverflow.com/questions/49811043/relationship-between-event-loop-libuv-and-v8-engine
https://stackoverflow.com/questions/50115031/does-v8-have-an-event-loop
https://stackoverflow.com/questions/67826673/nodejs-event-loop-in-libuv-and-v8
-->

## Библиотека libuv

Библиотека отвечающая за неблокирующие операции и взаимодействие с операционной системой в Node.js.

Для эмуляции неблокирующего ввода/вывода использует внутри потоки (именно в ОС Linux, в других ОС такого нет).

> [!IMPORTANT]
> **В Linux**, на текущий момент, все операции с локальными файлами — блокирующие.

**Особенности**
- По-умолчанию поднимаются 4 потока (именно в ОС Linux, в других ОС такого нет).

[К оглавлению](../../README.md#languages-javascript)

## Цикл событий (Event Loop)

Механизм Event Loop'a находится в libuv.

В Node.js цикл событий позволяет выполнять неблокирующие операции ввода/вывода путем выгрузки операций в ядро системы, когда это возможно.

Когда одна из этих операций завершается, ядро сообщает Node.js, что соответствующая этой операции функция обратного вызова (коллбэк) может быть добавлена в очередь опроса.

**Упрощённый порядок выполнения операций (фазы):**
- Таймеры (_кроме_ `setImmediate`).
- I/O коллбэки выполненных операций.
- Ожидание и подготовка (внутренние процессы цикла событий, может быть выполнен только `process.nextTick()`).
- Опрос (I/O операции, входящие: соединения, данные и т.д. Ставятся ядром в очередь).
  - Сначала выполнение скриптов для таймеров, порог которых истек.
  - Затем обработка событий из очереди опроса.
  - Может простаивать в ожидании задач или таймеров
  - Если в процессе ожидания истек порог таймера - он выполнится.
- Проверка (здесь запускается `setImmediate`).
- Коллбеки `close`.
- Проверка ожидается ли завершение каких-либо асинхронных операций ввода/вывода или таймеров, и завершает работу, если их нет.

**Особенности:**
Каждая фаза имеет очередь колбеков работающую по принципу FIFO. 
Каждая фаза выполняет сначала операции относящиеся к ней, а затем колбеки из очереди.
Фаза завершается, когда очередь колбеков исчерпана или если обработано максимально допустимое количество колбеков.

[К оглавлению](../../README.md#languages-javascript)

### Стек

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack). 

Стек определяет порядок выполнения кода и хранит локальные переменные.

Для переменных ссылочного типа на стеке хранится только указатель на данные в куче.

Если в рамках выполнения текущей функции (first) вызывается другая функция (second):
- Контекст текущей функции (first) помещается в стек вызовов.
- Новый контекст вызываемой функции (sercond) помещается в стек вызовов выше текущей.
- Когда выполнится вызываемая функция (second) ее контекст удаляется из стека вызовов.
- Выполнение передается контексту текущей функции (first).
- Когда выполняется текущая функция (first) ее контекст так же удаляется из стека вызовов.

[К оглавлению](../../README.md#languages-javascript)

### Куча

Область памяти, в которой хранятся ссылочные типы данных.

Может содержать таймеры и хранить значения переменных.

Функция-запуска таймеров вытягивает из кучи обработчик таймера с наименьшим временем и сравнивает это значение с временем выполнения событийного цикла. 
В случае, если время таймера меньше, то этот таймер останавливается (удаляется из кучи, его обработчик тоже удаляется из кучи). 
Далее идет проверка, нужно ли его перезапустить.

[К оглавлению](../../README.md#languages-javascript)

### Очередь

Это список задач для обработки. При выполнении задачи она удаляется из очереди, и код обработки помещается на стек.

**Особенности**
- Задача по сути является функцией с параметрами.
- Выполнение задачи вызывает ассоциированную с ней функцию, контекст которой в свою очередь помещается в стек вызовов.
- Задача считается выполненной, когда связанный с ней стек вызовов пуст.
- Каждая задача выполняется полностью, прежде чем начнёт обрабатываться следующая.

**Выборка задач из очереди**
- Выполнение микрозадач. Цикл событий обработает все микрозадачи до того, как перейдёт к следующей макрозадаче в очереди.
- Переход к следующей макрозадаче. После того как все микрозадачи выполнены, цикл событий возвращается к выбору и запуску следующей макрозадачи из очереди.
- Если в процессе выполнения макрозадачи возникают микрозадачи, они получают приоритет. Только после обработки всех микрозадач будет взята в работу одна следующая макрозадача.

[К оглавлению](../../README.md#languages-javascript)

## Микро и макро задачи (таски)

**Приоритет выполнения:** сначала будут обработаны задачи в стэке, далее микрозадачи и только после них будет выполнена макрозадача.

**Микрозадачи (или микротаски)** — это отложенные задачи, которые имеют приоритет над макрозадачами. Микрозадачи выполняются непосредственно после текущей задачи.
- операции с промисами (например, `Promise.then`, `Promise.catch`, `Promise.finally`, `fetch()` и так далее);
- операции с очередью мутации (например, используемые в API `MutationObserver` для наблюдения за изменениями DOM);
- операции, связанные с `queueMicrotask`, — функцией для явного добавления микрозадач.

**Макрозадачи (или макротаски)** — это тоже отложенные задачи, у которых меньший приоритет по сравнению с микрозадачами. Макрозадачи разделяются циклами Event Loop.
- обработка таймеров (`setTimeout`, `setInterval`, `setImmediate`);
- обработка событий пользовательского ввода (например, клики, скроллинг);
- выполнение AJAX-запросов.
- I/O операции.

**Порядок обработки в каждом цикле:**
- Основной поток (может быть пустым).
- Микрозадачи (может быть пустым).
- Макрозадачи (может быть пустым).

**Пример кода для понимания:**
```javascript 
console.log('Начало скрипта'); // основной поток, выполняется сразу

// setTimeout1 - Макрозадача созданная в основном потоке
setTimeout(() => { // регистрация макротаски, будет выполнена в последующих циклах, в порядке истечения времени или порядка добавления (при времени 0)
    console.log('Макрозадача: setTimeout1'); // выполнится при обработке контекста макротаски

    // PromiseInTimeout1 - Микрозадача созданная внутри макрозадачи
    Promise.resolve().then(() => { // регистрация микротаски во время обработки макротаски, будет выполнена после обработки контекста макротаски
        console.log('Микрозадача: обработка промиса[1] внутри setTimeout1'); // выполнится во время обработки микротаски PromiseInTimeout1
    });

    // PromiseInTimeout2 - Микрозадача созданная внутри макрозадачи
    Promise.resolve().then(() => { // регистрация микротаски во время обработки макротаски, будет выполнена после обработки контекста макротаски
        console.log('Микрозадача: обработка промиса[2] внутри setTimeout1'); // выполнится во время обработки микротаски PromiseInTimeout2
    });

    console.log('Макрозадача: setTimeout1 закончена'); // выполнится при обработке контекста макротаски
}, 0);

// setTimeout2 - Макрозадача созданная в основном контексте
setTimeout(() => { // регистрация макротаски, будет выполнена в последующих циклах, в порядке истечения времени или порядка добавления (при времени 0)
    console.log('Макрозадача: setTimeout2');
}, 0);

// Promise1 - Микрозадача созданная в основном потоке
Promise.resolve().then(() => { // регистрация микротаски, будет выполнена после основного потока
    console.log('Микрозадача: обработка первого промиса');
});

console.log('Конец скрипта'); // основной поток, выполняется сразу

// Будет выведено:
// Начало скрипта
// Конец скрипта
// Микрозадача: обработка первого промиса
// Макрозадача: setTimeout1
// Макрозадача: setTimeout1 закончена
// Микрозадача: обработка промиса[1] внутри setTimeout1
// Микрозадача: обработка промиса[2] внутри setTimeout1
// Макрозадача: setTimeout2
```

**Описание примера кода:**
- **Цикл 1:**
  - _Основной поток_
    - Вывод `Начало скрипта`
    - Добавление в очередь макрозадач `setTimeout1`
    - Добавление в очередь макрозадач `setTimeout2`
    - Добавление в очередь микрозадач `Promise1`
    - Вывод `Конец скрипта`
  - _Микрозадачи_
    - Выполнение микрозадачи `Promise1`
    - Вывод `Микрозадача: обработка первого промиса`
  - _Макрозадачи_
    - Макрозадача `setTimeout1` ожидает выполнения в следующих циклах
    - Макрозадача `setTimeout2` ожидает выполнения в следующих циклах
- **Цикл 2:**
  - _Основной поток_
    - Получение из очереди макрозадачи `setTimeout1`
    - Вывод `Макрозадача: setTimeout1`
    - Добавление в очередь микрозадач `PromiseInTimeout1`
    - Добавление в очередь микрозадач `PromiseInTimeout2`
    - Вывод `Макрозадача: setTimeout1 закончена`
  - _Микрозадачи_
    - Выполнение микрозадачи `PromiseInTimeout1`
    - Вывод `Микрозадача: обработка промиса[1] внутри setTimeout1`
    - Выполнение микрозадачи `PromiseInTimeout2`
    - Вывод `Микрозадача: обработка промиса[2] внутри setTimeout1`
  - _Макрозадачи_
    - Макрозадача `setTimeout2` ожидает выполнения в следующих циклах
- **Цикл 3:**
  - _Основной поток_
    - Получение из очереди макрозадачи `setTimeout2`
    - Вывод `Макрозадача: setTimeout2`
  - _Микрозадачи_
    - отсутствуют
  - _Макрозадачи_
    - отсутствуют
- Остановка скрипта

[К оглавлению](../../README.md#languages-javascript)

## process.nextTick()

Сразу помещается в текущий цикл (фазу). 

Будет обрабатываться после завершения текущей операции, независимо от текущей фазы цикла событий.

Когда вызывается `process.nextTick()` на любой фазе, все коллбэки, переданные процессу `process.nextTick()`, будут разрешаться до того, как цикл событий продолжится.

Удобно обращаться к коллбекам в функциях - гарантирует выполнение функции и вызов колбека. 
В частности, если синхронная функция вызывается с асинхронной сигнатурой (await).

**Варианты использования**
- Обрабатывать ошибки, очищать любые ненужные ресурсы или, возможно, повторять попытку до продолжения цикла обработки событий.
- Иногда необходимо разрешить выполнение коллбэка после разбора стека вызовов, но до продолжения цикла событий.

[К оглавлению](../../README.md#languages-javascript)

## setImmediate()

Срабатывает на следующей итерации или "тике" цикла событий.

Обработается только в фазе Проверки - выполнится после всех событий ввода/вывода.

[К оглавлению](../../README.md#languages-javascript)

# Пример кода с описанием цикла событий и работы с макро и микро задачами

**Исходный код**
```javascript
const checkOrder = function () {
    console.log('1');

    const asyncFn = async function asyncFn() {
        console.log('2');
        await Promise.resolve(null);
        console.log('4');
    };
    asyncFn();

    new Promise((resolve) => {
        setTimeout(() => {
            resolve();
            console.log('5');
        }, 0);
    }).then(() => {
        console.log('6');
    });

    console.log('3');
};
checkOrder();
```

**Описание микро и макро задач**
- **Цикл 1:**
  - _Основной поток_
    - Вывод `console.log('1')`
    - Вывод `console.log('2')`
    - Добавление в очередь микрозадач `await Promise.resolve(null)`
    - Добавление в очередь микрозадач `new Promise`
    - Вывод `console.log('3')`
  - _Микрозадачи_
    - Выполнение микрозадачи `await Promise.resolve(null)`
    - Вывод `console.log('4')`
    - Выполнение микрозадачи `new Promise`
    - Добавление в очередь макрозадач `setTimeout`
  - _Макрозадачи_
    - Макрозадача `setTimeout` ожидает выполнения в следующих циклах
- **Цикл 2:**
  - _Основной поток_
    - Получение из очереди макрозадачи `setTimeout`
    - Получение ответа для микрозадачи `new Promise`
    - Вывод `console.log('5')`
  - _Микрозадачи_
    - Выполнение микрозадачи `new Promise`
    - Вывод `console.log('5')`
  - _Макрозадачи_
    - отсутствуют
- Остановка скрипта

[К оглавлению](../../README.md#languages-javascript)

> [!IMPORTANT]
> Если вы заметили ошибку, неточность, нехватку информации, пожалуйста, сообщите мне.
