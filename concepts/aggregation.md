# Агрегирование

Создание нового класса из уже существующих классов путём их включения.

> :thinking: **IMHO**
>
> Общий класс при инициализации не инициализирует все необходимые ему дополнительные классы (элементы композиции) они создаются отдельно и передаются в общий класс как параметры. При удалении экземпляра основного класса не будут удалены экземпляры компонентов, они останутся существовать вне зависимости от экземпляра основного класса.

[К оглавлению](../README.md)

Агрегирование удобна, когда мы описываем отношения "есть".

Имеет отношение "часть-целое" между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Вложенные объекты нового класса обычно объявляются закрытыми, что делает их недоступными извне. С другой стороны, создатель класса может изменять эти объекты, не нарушая при этом работы существующего клиентского кода. Кроме того, замена вложенных объектов на стадии выполнения программы позволяет динамически изменять её поведение. Механизм наследования такой гибкостью не обладает.

На базе агрегирования реализуется методика делегирования, когда поставленная перед внешним объектом задача перепоручается внутреннему объекту, решающему задачи такого рода.

По сути является более слабо связанным вариантом [композиции](composition.md) - тут "части" основного класса не зависят от него, а существуют параллельно, просто предоставляя ссылку на себя для использования.

**Плюсы:**
- Более слабая связанность между объектом и его клиентом. Теперь мы можем использовать интерфейсы и одному объекту не нужно знать, как именно создавать другой объект.
- Большая гибкость. Вытекает из первого пункта

**Минусы:**
- Выставление наружу деталей реализации. Поскольку клиент класса должен предоставить зависимость в момент создания объекта, то сам факт этого отношения становится известен клиенту.
- Из первого пункта вытекает увеличение сложности в работе клиентов, а также большая "жесткость" решения в долгосрочной перспективе.

**Совет по применению агрегации:**
- Когда классы не представляют собой одну предметную область.
- Когда наследник не является корректным подтипом предка.
- Когда код предка полностью или частично не подходит для наследника.

В остальных случаях, возможно, стоит использовать [наследование](inheritance.md).

[К оглавлению](../README.md)
