**[Концепции, понятия, термины](../README.md#concepts) ::**
# Агрегирование

Создание нового класса из уже существующих классов путём их включения.

> :thinking: **IMHO**
>
> Не является зависимостью. Общий класс при инициализации не инициализирует все необходимые ему дополнительные классы они создаются отдельно и передаются в общий класс как параметры конструктора или метода. При удалении экземпляра основного класса не будут удалены экземпляры агрегированных классов - они останутся существовать вне зависимости от экземпляра основного класса.

[К оглавлению](../README.md#concepts)

Агрегирование удобна, когда мы описываем отношения "есть".

Является частным случаем [ассоциации](association.md).

Имеет отношение "часть-целое" между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Вложенные объекты нового класса обычно объявляются закрытыми, что делает их недоступными извне. С другой стороны, создатель класса может изменять эти объекты, не нарушая при этом работы существующего клиентского кода. Кроме того, замена вложенных объектов на стадии выполнения программы позволяет динамически изменять её поведение. Механизм наследования такой гибкостью не обладает.

На базе агрегирования реализуется методика делегирования, когда поставленная перед внешним объектом задача перепоручается внутреннему объекту, решающему задачи такого рода.

По сути является более слабо связанным вариантом [композиции](composition.md) - тут "части" основного класса не зависят от него, а существуют параллельно, просто предоставляя ссылку на себя для использования.

**Плюсы:**
- Более слабая связанность между объектом и его клиентом. Теперь мы можем использовать интерфейсы и одному объекту не нужно знать, как именно создавать другой объект.
- Большая гибкость.

**Минусы:**
- Выставление наружу деталей реализации. Поскольку клиент класса должен предоставить зависимость в момент создания объекта, то сам факт этого отношения становится известен клиенту.
- Из первого пункта вытекает увеличение сложности в работе клиентов, а также большая "жесткость" решения в долгосрочной перспективе.
- Ситуация, когда ассоциированный класс будет удален, а использующий его класс еще будет существовать и пытаться использовать методы удаленного класса.

**Совет по применению агрегации:**
- Когда классы представляют собой разные предметные области.
- Когда наследник не является корректным подтипом предка.
- Когда код предка полностью или частично не подходит для наследника.

В остальных случаях, возможно, стоит использовать [наследование](inheritance.md).

[К оглавлению](../README.md#concepts)
