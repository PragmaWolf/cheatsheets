# Идемпотентность

Свойство объекта или операции, когда повторное применение операции или обращение к объекту будет давать тот же результат, что и при первом.

[К оглавлению](../README.md)

Действие, многократное повторение которого эквивалентно однократному. Помогает избежать неожиданностей, делая системы более надежными.

Идемпотентность решает проблему непредсказуемых результатов при повторных операциях. Это значит, что не важно, сколько раз ты повторишь запрос или команду, изменение произойдет только один раз. Это упрощает написание программ, делая их более стабильными и предсказуемыми.

Знание об идемпотентности важно, потому что оно помогает предотвратить ошибки и избыточные действия в системе. Это особенно ценно при работе с сетевыми запросами и базами данных, где повторные действия могут привести к нежелательным последствиям. В итоге, это делает разработку более эффективной и надежно.

**Ключ идемпотентности** — это уникальный идентификатор, который позволяет системе распознавать повторные запросы. Это может быть что-то вроде UUID, который обеспечивает уникальность каждой операции. Использование такого ключа позволяет системе отличать новые запросы от повторных, предотвращая нежелательные дублирования операций.

Где контролировать идемпотентность, становится важным на этапе разработки. Хотя добавление логики контроля в контроллер может показаться простым решением, оно не является оптимальным. Вместо этого предпочтительнее внедрить блок контроля идемпотентности между клиентом и контроллером с бизнес-логикой, на уровне инфраструктуры. Это даст:
- Снижение зависимости от изменений в бизнес-логике контроллера. Это означает, что изменения в бизнес-логике не повлияют на механизм идемпотентности, что обеспечивает более гибкую и устойчивую систему.
- Унификация логики обработки для всех запросов. Это упрощает поддержку и обеспечивает единый стандарт в системе.

**Обработка нового запроса**

При поступлении нового запроса с уникальным ключом идемпотентности необходимо осуществить обработку, состоящую из следующих шагов:
- Новый запрос с уникальным ключом идемпотентности требует сохранения соответствующей информации в хранилище данных. Это позволяет отслеживать состояние запроса и его уникальный ключ.
- Для предотвращения возможных конфликтов блокировка устанавливается на этапе обработки запроса. Она гарантирует, что операции будут выполнены последовательно и предотвращает параллельную обработку запросов с одним ключом идемпотентности.
- Исполнение бизнес-логики контроллера.
- По завершении исполнения запроса блок отвечает за сохранение ответа в хранилище данных. Это позволяет клиенту получить тот же результат при повторном запросе.
- После сохранения ответа, блок освобождает блокировку, позволяя другим запросам с тем же ключом идемпотентности продолжить своё выполнение.

**Повторная обработка запроса**

Обработка повторного запроса, состоит из следующих этапов:
- Блок контроля идемпотентности проверяет наличие ключа из текущего запроса в хранилище данных.
- Если ключ уже имеется в хранилище и связан с сохранённым ответом, то блок возвращает этот ответ, обозначая успешное завершение запроса.
- Дальнейшая обработка запроса и выполнение бизнес-логики контроллера не происходят, поскольку запрос уже успешно обработан.

Одной из ключевых задач блока контроля идемпотентности является предотвращение параллельного исполнения конфликтующих запросов с использованием одного ключа. Для этого важно устанавливать блокировку на время обработки запроса. Одним из вариантов обработки запроса с заблокированным ключом является возврат ошибки.

В ходе обработки необходимо сопоставлять запросы, где ключ служит лишь одним из критериев. Мы должны сравнить текущий запрос с тем, который уже был исполнен с этим ключом. Это необходимо для предотвращения потенциальных угроз безопасности сервиса. Блок контроля идемпотентности нацелен на полное исключение возможности возврата сохранённого ответа на изменённый запрос, опираясь исключительно на совпадение ключа идемпотентности. В случае выявления несовпадений между запросами система немедленно выдаёт ошибку.

Долгосрочное хранение ключей избыточно, поскольку они остаются актуальными лишь в течение короткого времени, когда исполняются повторные запросы.

**Плюсы**
- повышение надежности и стабильности системы; 
- упрощение разработки и тестирования; 
- устойчивость к ошибкам и сбоям;
- более качественный пользовательский опыт.

**Минусы**
- необходимость дополнительного проектирования и реализации механизмов для контроля идемпотентности;
- может увеличить сложность системы;
- строгое применение идемпотентности может быть ограничено из-за специфики бизнес-логики или технических ограничений.

[К оглавлению](../README.md)
