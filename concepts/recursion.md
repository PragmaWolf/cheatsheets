**[Концепции, понятия, термины](../README.md#concepts) ::**
# Рекурсия

Поведение функции, при котором она вызывает сама себя. Чтобы функция выполнилась, нужно сначала получить ее результат при вызове с другим значением.

Рекурсивные функции, в отличие от цикла, не просто повторяются несколько раз, а работают "внутри" друг друга. Чтобы рекурсивный вызов закончился, нужно сразу прописать в функции условие выхода из рекурсии. Количество открытых в итоге функций называется глубиной рекурсии.

Обычно рекурсию применяют при расчетах, которые подразумевают использование результата одного шага для подсчитывания другого. Задачи можно решить и без рекурсии, но ее использование делает код проще, короче и быстрее, чем альтернативные варианты, но может слишком нагружать компьютер. Рекурсия позволяет разбивать сложные задачи на более простые подзадачи, что делает их решение более понятным и структурированным.

Циклами часто заменяют рекурсию - когда рекурсивные алгоритмы оказываются слишком ресурсоемкими. Для использования циклов в качестве замены рекурсии понадобятся дополнительные ухищрения.

Если не задать условия для выхода, рекурсия будет работать бесконечно, пока огромное количество ее экземпляров не "съест" всю оперативную память устройства и не переполнит стек вызовов.

**Базовый случай** — это условие, при котором рекурсивная функция прекращает вызывать саму себя.

**Рекурсивный вызов** — это часть функции, где она вызывает саму себя с новыми аргументами.

[К оглавлению](../README.md#concepts)

## Виды рекурсий:
- **Прямая** - вызывает сама себя напрямую.
- **Косвенная** - действует через "третью" функцию.
- **Линейная** - когда экземпляр функции вызывает сам себя только один раз, 
- **Каскадная** — когда экземпляр функции вызывает сам себя несколько раз.
- **Хвостовая** - вызов самой себя это последнее, что делает функция, перед тем как завершиться.

[К оглавлению](../README.md#concepts)

## Примеры рекурсивных расчетов:
- Вычисление факториала числа — последовательных умножений на предыдущее число. Например, 3! (факториал от трех) — это 1 * 2 * 3.
- Расчет и изображение фракталов — конструкций, где более мелкие элементы повторяют более крупные.
- Обход ветвящихся структур данных, например [графов](../data-structures/descriptions/graphs.md) и [деревьев](../data-structures/descriptions/trees.md).
- Компьютерный анализ естественного языка, фраз и предложений.
- Поиск пути в лабиринте и построение маршрутов — к примеру, алгоритмы [DFS (поиск в глубину)](../algorithms/graph-or-tree/depth-first-search.md) и [BFS (поиск в ширину)](../algorithms/graph-or-tree/breadth-first-search.md).
- Вычисления с числовыми рядами, например те же числа [Фибоначчи](../algorithms/recursion/fibonacci.md) или поиск простых чисел.
- Математические операции, требующие повторяющихся действий с разными значениями, к примеру возведение в степень больше 2, поиск максимума или минимума.
- Операции с системами счисления, к примеру перевод чисел из одной в другую.

[К оглавлению](../README.md#concepts)

## Рекурсивный процесс
Все расчеты откладываются "на потом". Конечный расчет делает тот экземпляр функции, который вызвали в последнюю очередь, а потом результаты по каскаду передаются предыдущим.

## Итеративный процесс
Функция считает всё, что может посчитать, и только потом вызывает свой новый экземпляр и передает наработки ему.

[К оглавлению](../README.md#concepts)

## Плюсы
- Ясность. Прочитать рекурсивный код обычно проще.
- Наглядность. Некоторые задачи - рекурсивные по самому своему определению (числа [Фибоначчи](../algorithms/recursion/fibonacci.md), факториалы, задачи на ряды, фракталы и так далее).
- Краткость. Рекурсивная функция обычно короче, чем реализация без рекурсии.
- Красота. Сам концепт многие считают красивым и изящным.
- Решение сложных задач. Некоторые задачи (обход деревьев, решение задач на графах) проще решать рекурсивно. 
- Модульность. Рекурсивные функции часто легче модифицировать и расширять, так как каждая функция решает конкретную подзадачу.

## Минусы
- Риск переполнения. Пока не выполнится последний вызов функции, все предыдущие не завершатся.
- Риск бесконечности. Остановить бесконечную рекурсию - это принудительно закрыть программу.
- Производительность. Рекурсивные функции могут быть менее эффективными по сравнению с итеративными решениями из-за накладных расходов на вызовы функций.
- Сложность отладки. Рекурсивные функции могут быть сложнее для отладки, особенно если они вызывают саму себя многократно и с разными аргументами.

[К оглавлению](../README.md#concepts)

## Практические советы
- Определите базовый случай. Убедитесь, что у вашей рекурсивной функции есть четко определенный базовый случай, чтобы избежать бесконечной рекурсии. Базовый случай должен быть простым и легко проверяемым.
- Используйте [мемоизацию](memoization.md). Для улучшения производительности рекурсивных функций - храните уже вычисленные значения.
- Проверяйте ограничения стека. Будьте осторожны с глубокой рекурсией и учитывайте ограничения стека вызовов в вашем языке программирования.
- Сравнивайте с итеративными решениями. В некоторых случаях итеративные решения могут быть более эффективными. Выбирайте наиболее подходящий подход для вашей задачи.
- Используйте хвостовую рекурсию. В некоторых языках программирования поддерживается оптимизация хвостовой рекурсии, которая позволяет избежать переполнения стека вызовов.
- Разделяйте задачи. Разделяйте сложные задачи на более простые подзадачи и решайте их рекурсивно. Это поможет сделать ваш код более модульным и легко расширяемым.

[К оглавлению](../README.md#concepts)

> [!IMPORTANT]
> Если вы заметили ошибку, неточность, нехватку информации, пожалуйста, сообщите мне.
