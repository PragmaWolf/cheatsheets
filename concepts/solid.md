**[Концепции, понятия, термины](../README.md#concepts) ::**
# Принципы SOLID

> [!IMPORTANT]
> Принцип — это не закон

При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени.

Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения, например, для удаления "дурно пахнущего кода".

Стратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.

[К оглавлению](../README.md#concepts)

## S <a name="s"></a>
> **SRP** (Single Responsibility Principle). Принцип единственной ответственности.

Класс (функция) должен и меть одну и только одну зону ответственности (решать только одну задачу). Сначала общую задачу нужно декомпозировать на несколько подзадач. Затем каждую подзадачу реализовать в отдельном классе (функции).

SRP предлагает разделять универсальные классы на конкретные, что сделает их простыми и лёгкими в обслуживании.

Когда стоит использовать этот принцип? 
- если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.
- если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.

Слепое следование принципу единственной ответственности приводит к избыточной сложности приложения, его поддержки и тестирования. SRP стоит применять только тогда, когда это оправдано. Например:
- объекту класса становится позволительно слишком много;
- доменная логика концентрируется только в одном классе;
- любое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;
- приходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;
- невозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.

Объединение ответственностей является общепринятой практикой и в этом нет ничего плохого, до тех пор пока это легко обслуживать. Следование принципу единственной ответственности зависит от функций программного продукта и является труднейшим при проектировании приложений.

[К оглавлению](../README.md#concepts)

## O <a name="o"></a>
> **OCP** (Open-Closed Principle). Принцип открытости/закрытости.

Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Программные компоненты нужно спроектировать таким образом, чтобы их можно было расширять новым функционалом, не меняя исходный код.

Термин "принцип открытости/закрытости" имеет два значения:
- Принцип открытости/закрытости Мейера.
- Полиморфный принцип открытости/закрытости.

**Принцип открытости/закрытости Мейера**

Однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или изменённые функции требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через механизм наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса. Реализация может быть переопределена через наследование, но спецификации интерфейса могут измениться. Существующая реализация должна быть закрыта для изменений, но новые реализации не обязаны использовать существующий интерфейс.

**Полиморфный принцип открытости/закрытости**

Поддерживает идею наследования от абстрактных базовых классов. Спецификации интерфейсов могут быть переиспользованы через наследование, но реализации переиспользовать необязательно. Существующий интерфейс должен быть закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот интерфейс.

[К оглавлению](../README.md#concepts)

## L <a name="l"></a>
> **LSP** (Liskov Substitution Principle). Принцип подстановки Лисков.

Производные классы должны заменять свои базовые классы. Базовый класс (класс, от которого производные классы наследуют свойства и методы) должен быть заменим объектами производных классов без изменения ожидаемого поведения программы. Производный класс должен сохранять все свойства базового класса и не изменять их семантику. Объекты производных классов должны безопасно заменять друг друга и базовый класс.

Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.

Замещение - если тип В является подтипом А (наследником, расширением типа), тогда объекты типа А в программе могут быть замещены объектами типа В без каких-либо изменений свойств этой программы.

Принцип подстановки Лисков имеет близкое отношение к методологии контрактного программирования, и ведёт к некоторым ограничениям на то, как контракты могут взаимодействовать с наследованием:
- предусловия не могут быть усилены в подклассе;
- постусловия не могут быть ослаблены в подклассе;
- исторические ограничения ("правило истории") — подкласс не должен создавать новых мутаторов свойств базового класса, если базовый класс не предусматривал методов для изменения определённых в нём свойств, подтип этого класса так же не должен создавать таких методов. Неизменяемые данные базового класса не должны быть изменяемыми в подклассе.

[К оглавлению](../README.md#concepts)

## I <a name="i"></a>
> **ISP** (Interface Segregation Principle). Принцип разделения интерфейса.

Клиенты не должны зависеть от интерфейсов, которые они не используют. Нужно создавать только небольшие и узконаправленные интерфейсы, не перегруженные ненужными методами. Каждый интерфейс должен существовать для определенных задач и содержать только те методы, которые эти задачи решают. Не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

Принцип разделения интерфейсов говорит о том, что слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.

[К оглавлению](../README.md#concepts)

## D <a name="d"></a>
> **DIP** (Dependency Inversion Principle). Принцип инверсии зависимостей.

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, но детали должны зависеть от абстракций. Код должен быть организован таким образом, чтобы зависимости между компонентами программы были основаны на абстракциях. Таким образом, компоненты легко заменить или изменить без воздействия на другие части системы:
- Использовать интерфейсы или абстрактные классы для определения зависимостей между компонентами.
- Следовать остальным принципам SOLID.
- Применять шаблоны проектирования, чтобы передавать зависимости извне вместо того, чтобы создавать их внутри компонентов (например Dependency Injection или Inversion of Control).

Суть состоит в том, что классы должны зависеть от абстракций, а не от конкретных деталей. Используется для минимизации связности (зацепления) в компьютерных программах. Может рассматриваться как уменьшение знаний о данных и поведении объекта (и связности с ним) до минимума, описанного интерфейсом.

[К оглавлению](../README.md#concepts)

> [!IMPORTANT]
> Если вы заметили ошибку, неточность, нехватку информации, пожалуйста, сообщите мне.
