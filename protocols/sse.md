**[Протоколы](../README.md#protocols) ::**
# События, посылаемые сервером (Server-Sent Events, SSE)

Push-технология (связь инициируется сервером, а не клиентом). Односторонняя передача данных с сервера клиенту. Сейчас стандартизируется как часть HTML5

Позволяет поддерживать постоянное соединение между клиентом и сервером для обмена данными в реальном времени. Информация передается и обновляется мгновенно или почти мгновенно с учетом физических задержек сети. Спроектирован для улучшения кросс-браузерного вещания посредством JavaScript API под названием EventSource.

Работает поверх стандартного [HTTP](http.md). Ограничение на количество подключений. Подходит для текстовых данных в кодировке UTF-8. Более простая настройка, чем [WebSocket](websocket.md).

Предусматривает встроенную функцию автоматического восстановления сетевого соединения.

Масштабирование через балансировку нагрузки с поддержкой сессий.

Удобно использовать, например, для новостных лент и оповещений с сервера. Широко используется для посылки сообщений об обновлениях или для посылки непрерывных потоков данных браузеру клиента.

[К оглавлению](../README.md#protocols)

## Установка соединения через HTTP/2

Клиент инициирует подключение с сервером, чтобы подписаться на события. При использовании [HTTP/2](http2.md) устанавливается одно [TCP-соединение](tcp-ip.md) для всего обмена данными между клиентом и сервером, включая как SSE-события, так и обычные [HTTP-запросы](http.md).

- Клиент отправляет обычный GET-запрос на сервер, чтобы подписаться на поток событий (с заголовком Accept: text/event-stream, указывающим, что он ожидает поток SSE).
- [HTTP/2](http2.md) позволяет использовать одно [TCP-соединение](tcp-ip.md) для всех взаимодействий клиента с сервером, что исключает необходимость в открытии новых соединений и снижает нагрузку на сеть.

[К оглавлению](../README.md#protocols)

## Ответ сервера и поток данных

Сервер принимает запрос и начинает отправлять данные в формате text/event-stream. Благодаря мультиплексированию [HTTP/2](http2.md) сервер может отправлять этот поток данных одновременно с другими ресурсами (CSS, JavaScript), используя одно и то же соединение.

После этого сервер начинает отправлять события в формате SSE, например, обновления состояния сервера или уведомления о новых событиях.

[К оглавлению](../README.md#protocols)

## Формат события SSE

События SSE передаются в виде текста, где каждое событие завершается пустой строкой для разделения сообщений.

[К оглавлению](../README.md#protocols)

## Управление соединением и автоматическое переподключение

Если соединение разрывается, браузер автоматически попытается переподключиться. В [HTTP/2](http2.md) переподключение происходит быстрее, так как открывается всего одно [TCP-соединение](tcp-ip.md), которое поддерживает все потоки данных, включая SSE.

- Клиент может отправить заголовок Last-Event-ID при переподключении, чтобы сообщить серверу, на каком событии он остановился.
- Сервер может продолжить отправку событий с нужного ID, что предотвращает потерю данных при разрыве соединения. Данные будут отправляться с нужного события.

[К оглавлению](../README.md#protocols)

## Производительность

- **Меньше потребление памяти и CPU.** Однонаправленное соединение снижает нагрузку на процессор и память по сравнению с [WebSockets](websocket.md).
- **Оптимизированная работа в сетях.** Использует [HTTP](http.md) и работает на стандартных портах, что облегчает работу через прокси и балансировщики нагрузки и позволяет эффективнее использовать сетевые ресурсы.
- **Энергопотребление.** Менее требователен к батарее на мобильных устройствах, так как поддерживает постоянное соединение без дополнительных проверок активности (например, ping/pong).

[К оглавлению](../README.md#protocols)

## Когда лучше использовать

- **Приложения с однонаправленным потоком данных от сервера к клиенту.** Хорошо подходит для лент новостей, уведомлений, ценовых обновлений и других данных, которые сервер отправляет клиенту без необходимости получать ответы.
- **Сценарии с меньшими требованиями к частоте обновления.** Если данные обновляются с предсказуемой или средней частотой.
- **Поддержка автоматического переподключения и восстановления после разрывов.** Автоматически восстанавливает соединение, если оно разрывается, и не требует сложной логики на стороне клиента.
- **Энергосбережение на мобильных устройствах.** Менее требователен к энергии на мобильных устройствах, чем [WebSockets](websocket.md), так как оно не требует постоянного пинга для поддержания соединения.
- **Поддержка стандартных сетей и кэширования.** Работает поверх [HTTP](http.md) и использует текстовые данные, что упрощает поддержку в корпоративных сетях и через прокси-серверы.

[К оглавлению](../README.md#protocols)

## Реализация на стороне клиента

Чтобы начать получать данные, нужно просто создать `new EventSource(url)` (поддерживает кросс-доменные запросы).
Браузер установит соединение с `url` и будет поддерживать его открытым, ожидая события. Сервер должен ответить со статусом `200` и заголовком `Content-Type: text/event-stream`, затем он должен поддерживать соединение открытым и отправлять сообщения в особом формате:
```text
data: message 1

data: message 2
data: message 2 continue

data: {"foo": "bar", "message": "Message\n with two rows"}
```

- Текст сообщения указывается после `data:`, пробел после двоеточия необязателен.
- Сообщения разделяются двойным переносом строки `\n\n`.
- Чтобы разделить сообщение на несколько строк, мы можем отправить несколько `data:` подряд.
- Сложные сообщения обычно отправляются в формате `JSON`, в котором перевод строки кодируется как `\n`, так что в разделении сообщения на несколько строк обычно нет нужды.

Для каждого сообщения генерируется событие `message`:
```javascript
const eventSource = new EventSource(url)

eventSource.onmessage = function(event) {
  // обработка сообщения
};
```

После создания `new EventSource` подключается к серверу и, если соединение обрывается, – переподключается. Сервер может выставить рекомендуемую задержку, указав в ответе `retry: (в миллисекундах)`. Поле `retry:` может посылаться как вместе с данными, так и отдельным сообщением.
- Если сервер хочет остановить попытки переподключения, он должен ответить со статусом `204`.
- Если браузер хочет прекратить соединение, он может вызвать `eventSource.close()`.

Чтобы правильно возобновить подключение, каждое сообщение должно иметь поле `id:` (указывается сервером после данных data сообщения, чтобы обновление `lastEventId` произошло после того, как сообщение будет получено). Получая сообщение с указанным `id:`, браузер:
- Установит его значение свойству `eventSource.lastEventId`.
- При переподключении отправит заголовок `Last-Event-ID` с этим `id`, чтобы сервер мог переслать последующие сообщения.

У объекта `EventSource` есть свойство `readyState`, имеющее одно из трёх значений:
- `EventSource.CONNECTING = 0;` - подключение или переподключение.
- `EventSource.OPEN = 1;` - подключено.
- `EventSource.CLOSED = 2;` - подключение закрыто.

По умолчанию объект `EventSource` генерирует 3 события:
- `message` – получено сообщение, доступно как `event.data`.
- `open` – соединение открыто.
- `error` – не удалось установить соединение, например, сервер вернул статус `500`.

Сервер может указать другой тип события с помощью `event: ...` в начале сообщения. Чтобы начать слушать пользовательские события, нужно использовать `addEventListener`, а не `onmessage`.

[К оглавлению](../README.md#protocols)

> [!IMPORTANT]
> Если вы заметили ошибку, неточность, нехватку информации, пожалуйста, сообщите мне.
