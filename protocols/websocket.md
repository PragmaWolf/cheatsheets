**[Протоколы](../README.md#protocols) ::**
# WebSocket

Протокол связи поверх [TCP-соединения](tcp-ip.md) для обмена сообщениями между клиентом и сервером. Использует постоянное соединение.

Позволяет поддерживать постоянное соединение между клиентом и сервером для обмена данными в реальном времени. Информация передается и обновляется мгновенно или почти мгновенно с учетом физических задержек сети.

Удобно для бинарных данных. Подходит для реализации обмена данными в реальном времени. Позволяет создавать множество подключений. Предпочтителен при очень высоком трафике. 

Может столкнуться с проблемами при попытках обновления [HTTP-соединения](http.md) при включенном файерволе. Не предусмотрена встроенная функция автоматического восстановления сетевого соединения.

Масштабирование приложения с WebSocket можно реализовать брокерами сообщений или сервисами pub/sub.

[К оглавлению](../README.md#protocols)

## Handshake

Является специальным начальным [HTTP-запросом](http.md), инициируемым клиентом. Содержит особые заголовки, указывающие, что клиент хочет переключиться на WebSocket-протокол.

- Клиент отправляет [HTTP-запрос](http.md) с методом GET на сервер и заголовком Upgrade: websocket, который указывает серверу желание переключиться с HTTP на WebSocket-протокол.
- Заголовок Connection: Upgrade подтверждает намерение перейти на другой протокол.
- В заголовке Sec-WebSocket-Key клиент отправляет случайную строку, которая будет использоваться сервером для создания уникального ключа для данного соединения.
- Сервер отвечает с кодом статуса 101 Switching Protocols, если поддерживает WebSocket. Далее включает заголовок Sec-WebSocket-Accept, в котором находится подтвержденный ключ.
- После успешного Handshake соединение переходит в WebSocket-протокол. Клиент и сервер теперь могут обмениваться данными в рамках постоянного соединения.

Ключ безопасности в заголовке Sec-WebSocket-Accept генерируется сервером на основе ключа клиента Sec-WebSocket-Key с использованием следующего алгоритма:
- Сервер берет значение Sec-WebSocket-Key, добавляет к нему фиксированную строку "258EAFA5-E914-47DA-95CA-C5AB0DC85B11".
- Результат хэшируется с помощью SHA-1.
- Полученный хэш преобразуется в формат Base64 и отправляется клиенту в заголовке Sec-WebSocket-Accept.

[К оглавлению](../README.md#protocols)

## Передача данных

Данные передаются в виде фреймов — компактных порций данных, которые могут быть отправлены в любом направлении. Фреймы минимальны по размеру, что позволяет сократить объем передаваемых данных и уменьшить задержку.

- **Фреймы данных**. Каждый фрейм включает служебную информацию (например, флаги начала и конца сообщения), а также полезную нагрузку (payload), содержащую данные.
- **Типы фреймов**. Поддерживается несколько типов фреймов, включая текстовые (обычно в формате JSON) и бинарные (например, для передачи изображений или других медиаданных), что позволяет передавать данные любого формата.
- **Фреймы управления**. Используются для закрытия соединения, проверки активности соединения (ping/pong), а также других служебных задач.

[К оглавлению](../README.md#protocols)

## Производительность

Постоянное двустороннее соединение приводит к специфическим требованиям для обработки большого количества подключений.
- **Использование памяти и CPU.** Каждый подключенный клиент занимает ресурсы сервера (память, процессорное время, сокеты).
- **Потребление сетевых ресурсов.** Соединения могут передавать данные часто и с высокой скоростью, что увеличивает сетевой трафик. Кроме того, пакеты ping/pong для проверки активности соединения также требуют ресурсов.
- **Энергопотребление на мобильных устройствах.** Постоянное соединение и активный обмен данными приводят к увеличению энергопотребления на устройствах пользователей, особенно на мобильных, так как устройство должно часто выходить в сеть для поддержания соединения.

[К оглавлению](../README.md#protocols)

## Когда лучше использовать

- **Приложения с высокой интерактивностью и двусторонней связью.** Идеально подходят для чатов, игр, и финансовых платформ, где пользователи взаимодействуют друг с другом и отправляют данные на сервер с минимальной задержкой.
- **Сценарии с частыми и неограниченными обновлениями.** Поддерживают постоянное двустороннее соединение, что позволяет обмениваться данными в любой момент.
- **Сложные интерфейсы с большим объемом данных.** Если приложение постоянно получает или отправляет данные в обе стороны (платформа для мониторинга в реальном времени с большим количеством пользователей).
- **Работа с бинарными данными.** Поддерживают как текстовые, так и бинарные данные, что делает их подходящими для мультимедийных приложений, передающих изображения, видео или файлы.
- **Низкая задержка и критичность времени отклика.** В сценариях, где задержка в миллисекунды может влиять на пользовательский опыт, например, в торговых платформах - позволяют передавать данные в реальном времени с минимальной задержкой.

[К оглавлению](../README.md#protocols)

> [!IMPORTANT]
> Если вы заметили ошибку, неточность, нехватку информации, пожалуйста, сообщите мне.
